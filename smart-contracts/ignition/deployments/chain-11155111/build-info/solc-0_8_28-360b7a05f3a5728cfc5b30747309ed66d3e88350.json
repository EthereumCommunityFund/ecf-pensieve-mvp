{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-360b7a05f3a5728cfc5b30747309ed66d3e88350",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/HarbergerFactory.sol": "project/contracts/HarbergerFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/HarbergerFactory.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.28;\n\nimport {ValuationTaxEnabledSlot} from \"./ValuationTaxEnabledSlot.sol\";\nimport {ValuationTaxShieldedSlot} from \"./ValuationTaxShieldedSlot.sol\";\n\n/**\n * @title HarbergerFactory\n * @notice Deploys Harberger ad slots and tracks their metadata.\n */\ncontract HarbergerFactory {\n    uint256 private constant RATE_DENOMINATOR = 1e4; // basis points\n\n    error Unauthorized();\n    error InvalidParameter();\n    error GlobalAddressesUnset();\n    error SlotDoesNotExist();\n    error NoPendingOwner();\n\n    enum SlotType {\n        Unknown,\n        ValuationTaxEnabled,\n        ValuationTaxShielded\n    }\n\n    struct SlotInfo {\n        address slotAddress;\n        SlotType slotType;\n    }\n\n    address public owner;\n    address public pendingOwner;\n    address public treasury;\n    address public governance;\n\n    uint256 public slotIdCounter;\n\n    mapping(uint256 => SlotInfo) private _slots;\n    mapping(address => SlotType) public slotTypeByAddress;\n    address[] private _valuationTaxEnabledSlots;\n    address[] private _valuationTaxShieldedSlots;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n    event GlobalAddressesConfigured(address indexed treasury, address indexed governance);\n    event ValuationTaxEnabledSlotCreated(uint256 indexed slotId, address slotAddress);\n    event ValuationTaxShieldedSlotCreated(uint256 indexed slotId, address slotAddress);\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert Unauthorized();\n        _;\n    }\n\n    constructor(address treasury_, address governance_) {\n        owner = msg.sender;\n        if (treasury_ != address(0) && governance_ != address(0)) {\n            treasury = treasury_;\n            governance = governance_;\n            emit GlobalAddressesConfigured(treasury_, governance_);\n        }\n    }\n\n    function setGlobalAddresses(address treasury_, address governance_) external onlyOwner {\n        if (treasury_ == address(0) || governance_ == address(0)) revert InvalidParameter();\n        treasury = treasury_;\n        governance = governance_;\n        emit GlobalAddressesConfigured(treasury_, governance_);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        if (newOwner == address(0)) revert InvalidParameter();\n        pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner, newOwner);\n    }\n\n    function acceptOwnership() external {\n        address newOwner = pendingOwner;\n        if (newOwner == address(0)) revert NoPendingOwner();\n        if (msg.sender != newOwner) revert Unauthorized();\n        address previousOwner = owner;\n        owner = newOwner;\n        pendingOwner = address(0);\n        emit OwnershipTransferred(previousOwner, newOwner);\n    }\n\n    function createValuationTaxEnabledSlot(\n        uint256 bondRate,\n        uint256 contentUpdateLimit,\n        uint256 taxPeriodInSeconds,\n        uint256 annualTaxRate,\n        uint256 minBidIncrementRate,\n        uint256 minValuation,\n        uint256 dustRate\n    ) external onlyOwner returns (uint256 slotId, address slotAddress) {\n        if (treasury == address(0) || governance == address(0)) revert GlobalAddressesUnset();\n        if (taxPeriodInSeconds == 0 || annualTaxRate == 0) revert InvalidParameter();\n        if (bondRate == 0 || bondRate > RATE_DENOMINATOR) revert InvalidParameter();\n        if (minValuation == 0) revert InvalidParameter();\n        if (dustRate > RATE_DENOMINATOR) revert InvalidParameter();\n\n        slotId = ++slotIdCounter;\n\n        ValuationTaxEnabledSlot slotInstance = new ValuationTaxEnabledSlot(\n            treasury,\n            governance,\n            bondRate,\n            contentUpdateLimit,\n            taxPeriodInSeconds,\n            annualTaxRate,\n            minBidIncrementRate,\n            minValuation,\n            dustRate\n        );\n\n        slotAddress = address(slotInstance);\n        _slots[slotId] = SlotInfo({slotAddress: slotAddress, slotType: SlotType.ValuationTaxEnabled});\n        slotTypeByAddress[slotAddress] = SlotType.ValuationTaxEnabled;\n        _valuationTaxEnabledSlots.push(slotAddress);\n\n        emit ValuationTaxEnabledSlotCreated(slotId, slotAddress);\n    }\n\n    function createValuationTaxShieldedSlot(\n        uint256 bondRate,\n        uint256 contentUpdateLimit,\n        uint256 taxPeriodInSeconds,\n        uint256 annualTaxRate,\n        uint256 minBidIncrementRate,\n        uint256 minValuation\n    ) external onlyOwner returns (uint256 slotId, address slotAddress) {\n        if (treasury == address(0) || governance == address(0)) revert GlobalAddressesUnset();\n        if (taxPeriodInSeconds == 0 || annualTaxRate == 0) revert InvalidParameter();\n        if (bondRate == 0 || bondRate > RATE_DENOMINATOR) revert InvalidParameter();\n        if (minValuation == 0) revert InvalidParameter();\n\n        slotId = ++slotIdCounter;\n\n        ValuationTaxShieldedSlot slotInstance = new ValuationTaxShieldedSlot(\n            treasury,\n            governance,\n            bondRate,\n            contentUpdateLimit,\n            taxPeriodInSeconds,\n            annualTaxRate,\n            minBidIncrementRate,\n            minValuation\n        );\n\n        slotAddress = address(slotInstance);\n        _slots[slotId] = SlotInfo({slotAddress: slotAddress, slotType: SlotType.ValuationTaxShielded});\n        slotTypeByAddress[slotAddress] = SlotType.ValuationTaxShielded;\n        _valuationTaxShieldedSlots.push(slotAddress);\n\n        emit ValuationTaxShieldedSlotCreated(slotId, slotAddress);\n    }\n\n    function getSlot(uint256 slotId) external view returns (SlotInfo memory info) {\n        info = _slots[slotId];\n        if (info.slotAddress == address(0)) revert SlotDoesNotExist();\n    }\n\n    function getValuationTaxEnabledSlots() external view returns (address[] memory slots_) {\n        slots_ = _valuationTaxEnabledSlots;\n    }\n\n    function getValuationTaxShieldedSlots() external view returns (address[] memory slots_) {\n        slots_ = _valuationTaxShieldedSlots;\n    }\n}\n"
      },
      "project/contracts/ValuationTaxEnabledSlot.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.28;\n\n/**\n * @title ValuationTaxEnabledSlot\n * @notice Harberger-style ad slot variant where only a fraction of the valuation is bonded on-chain.\n */\ncontract ValuationTaxEnabledSlot {\n    uint256 private constant RATE_DENOMINATOR = 1e4; // basis points (10000 = 100%)\n    uint256 private constant SECONDS_PER_YEAR = 365 days;\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private constant TAX_BASE = RATE_DENOMINATOR * SECONDS_PER_YEAR;\n\n    error Unauthorized();\n    error SlotOccupied();\n    error SlotVacant();\n    error InvalidAmount();\n    error InvalidParameter();\n    error ContentUpdateLimitReached();\n    error TaxStillActive();\n    error MinIncrementNotMet();\n    error TransferFailed();\n    error Reentrancy();\n\n    event SlotClaimed(address indexed newOwner, uint256 valuation, uint256 lockedAmount, uint256 paidThrough);\n    event SlotTakenOver(\n        address indexed previousOwner,\n        address indexed newOwner,\n        uint256 newValuation,\n        uint256 lockedAmount,\n        uint256 paidThrough\n    );\n    event SlotRenewed(address indexed owner, uint256 paidThrough);\n    event SlotForfeited(address indexed previousOwner);\n    event SlotReset(address indexed previousOwner);\n    event AdCreativeUpdated(address indexed owner, string uri);\n    event SlotPoked(address indexed operator, uint256 taxPaidUntil, uint256 valuationAfter);\n    event TreasuryPayment(uint256 amount);\n    event FundsSent(address indexed to, uint256 amount);\n\n    address public immutable treasury;\n    address public immutable governance;\n    address public immutable factory;\n\n    uint256 public immutable bondRate;\n    uint256 public immutable contentUpdateLimit;\n    uint256 public immutable taxPeriodInSeconds;\n    uint256 public immutable annualTaxRate;\n    uint256 public immutable minBidIncrementRate;\n    uint256 public immutable minValuation;\n    uint256 public immutable dustRate;\n\n    address public currentOwner;\n    uint256 public valuation;\n    uint256 public lockedValuation;\n    uint256 public baseValuation;\n    uint256 public taxPaidUntil;\n    uint256 public prepaidTaxBalance;\n    uint256 public contentUpdateCount;\n    string public currentAdURI;\n\n    uint256 private _status;\n\n    struct SlotDetails {\n        address currentOwner;\n        uint256 valuation;\n        uint256 lockedValuation;\n        uint256 prepaidTaxBalance;\n        uint256 taxPaidUntil;\n        uint256 timeRemainingInSeconds;\n        uint256 contentUpdateCount;\n        uint256 contentUpdateLimit;\n        uint256 taxPeriodInSeconds;\n        uint256 annualTaxRate;\n        uint256 minBidIncrementRate;\n        uint256 bondRate;\n        uint256 minValuation;\n        uint256 baseValuation;\n        uint256 dustRate;\n        string currentAdURI;\n        address treasury;\n        address governance;\n        bool isOccupied;\n    }\n\n    constructor(\n        address treasury_,\n        address governance_,\n        uint256 bondRate_,\n        uint256 contentUpdateLimit_,\n        uint256 taxPeriodInSeconds_,\n        uint256 annualTaxRate_,\n        uint256 minBidIncrementRate_,\n        uint256 minValuation_,\n        uint256 dustRate_\n    ) {\n        if (treasury_ == address(0) || governance_ == address(0)) revert InvalidParameter();\n        if (taxPeriodInSeconds_ == 0 || annualTaxRate_ == 0) revert InvalidParameter();\n        if (bondRate_ == 0 || bondRate_ > RATE_DENOMINATOR) revert InvalidParameter();\n        if (minValuation_ == 0) revert InvalidParameter();\n        if (dustRate_ > RATE_DENOMINATOR) revert InvalidParameter();\n\n        treasury = treasury_;\n        governance = governance_;\n        factory = msg.sender;\n        bondRate = bondRate_;\n        contentUpdateLimit = contentUpdateLimit_;\n        taxPeriodInSeconds = taxPeriodInSeconds_;\n        annualTaxRate = annualTaxRate_;\n        minBidIncrementRate = minBidIncrementRate_;\n        minValuation = minValuation_;\n        dustRate = dustRate_;\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        if (_status == _ENTERED) revert Reentrancy();\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != currentOwner) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyGovernance() {\n        if (msg.sender != governance) revert Unauthorized();\n        _;\n    }\n\n    function claim(uint256 newValuation, uint256 taxPeriods, string calldata newUri)\n        external\n        payable\n        nonReentrant\n    {\n        if (currentOwner != address(0)) revert SlotOccupied();\n        if (newValuation == 0 || taxPeriods == 0) revert InvalidParameter();\n        if (newValuation < minValuation) revert InvalidParameter();\n\n        uint256 lockedAmount = _calculateLockedAmount(newValuation);\n        uint256 taxDue = _calculateTax(newValuation, taxPeriods);\n        if (taxDue == 0) revert InvalidParameter();\n\n        uint256 requiredValue = lockedAmount + taxDue;\n        if (msg.value != requiredValue) revert InvalidAmount();\n\n        uint256 coverage = taxPeriodInSeconds * taxPeriods;\n\n        lockedValuation = lockedAmount;\n        valuation = newValuation;\n        baseValuation = newValuation;\n        currentOwner = msg.sender;\n        taxPaidUntil = block.timestamp + coverage;\n        contentUpdateCount = 0;\n        currentAdURI = newUri;\n\n        prepaidTaxBalance = taxDue;\n\n        emit SlotClaimed(msg.sender, newValuation, lockedAmount, taxPaidUntil);\n    }\n\n    function takeOver(uint256 newValuation, uint256 taxPeriods, string calldata newUri)\n        external\n        payable\n        nonReentrant\n    {\n        address previousOwner = currentOwner;\n        if (previousOwner == address(0)) revert SlotVacant();\n        _settleOverdueTax();\n\n        uint256 refundableTax = prepaidTaxBalance;\n        prepaidTaxBalance = 0;\n\n        if (taxPeriods == 0 || newValuation == 0) revert InvalidParameter();\n        if (newValuation < minValuation) revert InvalidParameter();\n\n        uint256 minValuationRequired = valuation + ((valuation * minBidIncrementRate) / RATE_DENOMINATOR);\n        if (newValuation < minValuationRequired) revert MinIncrementNotMet();\n\n        uint256 lockedAmount = _calculateLockedAmount(newValuation);\n        uint256 taxDue = _calculateTax(newValuation, taxPeriods);\n        if (taxDue == 0) revert InvalidParameter();\n        if (msg.value != lockedAmount + taxDue) revert InvalidAmount();\n\n        uint256 refundAmount = lockedValuation + refundableTax;\n        uint256 newPaidThrough = block.timestamp + (taxPeriodInSeconds * taxPeriods);\n\n        currentOwner = msg.sender;\n        valuation = newValuation;\n        lockedValuation = lockedAmount;\n        baseValuation = newValuation;\n        taxPaidUntil = newPaidThrough;\n        contentUpdateCount = 0;\n        currentAdURI = newUri;\n        prepaidTaxBalance = taxDue;\n\n        if (refundAmount != 0) {\n            _sendValue(payable(previousOwner), refundAmount);\n        }\n\n        emit SlotTakenOver(previousOwner, msg.sender, newValuation, lockedAmount, newPaidThrough);\n    }\n\n    function renew(uint256 taxPeriods) external payable nonReentrant onlyOwner {\n        if (taxPeriods == 0) revert InvalidParameter();\n        _settleOverdueTax();\n\n        uint256 taxDue = _calculateTax(valuation, taxPeriods);\n        if (taxDue == 0) revert InvalidParameter();\n        if (msg.value != taxDue) revert InvalidAmount();\n\n        uint256 coverage = taxPeriodInSeconds * taxPeriods;\n        taxPaidUntil = taxPaidUntil + coverage;\n\n        prepaidTaxBalance += taxDue;\n\n        emit SlotRenewed(msg.sender, taxPaidUntil);\n    }\n\n    function forfeit() external nonReentrant {\n        address previousOwner = currentOwner;\n        if (previousOwner == address(0)) revert SlotVacant();\n        _settleOverdueTax();\n        if (block.timestamp < taxPaidUntil) revert TaxStillActive();\n\n        uint256 payout = lockedValuation;\n        uint256 refundableTax = prepaidTaxBalance;\n        prepaidTaxBalance = 0;\n\n        currentOwner = address(0);\n        valuation = 0;\n        lockedValuation = 0;\n        baseValuation = 0;\n        taxPaidUntil = 0;\n        contentUpdateCount = 0;\n        currentAdURI = \"\";\n\n        _sendValue(payable(previousOwner), payout + refundableTax);\n\n        emit SlotForfeited(previousOwner);\n    }\n\n    function poke() external nonReentrant {\n        address previousOwner = currentOwner;\n        if (previousOwner == address(0)) revert SlotVacant();\n        if (block.timestamp < taxPaidUntil) revert TaxStillActive();\n\n        _settleOverdueTax();\n\n        if (lockedValuation == 0) {\n            currentOwner = address(0);\n            valuation = 0;\n            baseValuation = 0;\n            taxPaidUntil = 0;\n            contentUpdateCount = 0;\n            currentAdURI = \"\";\n            prepaidTaxBalance = 0;\n\n            emit SlotForfeited(previousOwner);\n        } else {\n            emit SlotPoked(msg.sender, taxPaidUntil, valuation);\n        }\n    }\n\n    function governanceReset() external nonReentrant onlyGovernance {\n        address previousOwner = currentOwner;\n        if (previousOwner == address(0)) revert SlotVacant();\n\n        _settleOverdueTax();\n\n        uint256 refundableTax = prepaidTaxBalance;\n        prepaidTaxBalance = 0;\n        uint256 payout = lockedValuation;\n\n        currentOwner = address(0);\n        valuation = 0;\n        lockedValuation = 0;\n        baseValuation = 0;\n        taxPaidUntil = 0;\n        contentUpdateCount = 0;\n        currentAdURI = \"\";\n\n        _sendValue(payable(previousOwner), payout + refundableTax);\n\n        emit SlotReset(previousOwner);\n    }\n\n    function updateAdCreative(string calldata newUri) external onlyOwner {\n        if (contentUpdateCount >= contentUpdateLimit) revert ContentUpdateLimitReached();\n\n        contentUpdateCount += 1;\n        currentAdURI = newUri;\n\n        emit AdCreativeUpdated(msg.sender, newUri);\n    }\n\n    function getSlotDetails() external view returns (SlotDetails memory details) {\n        details = SlotDetails({\n            currentOwner: currentOwner,\n            valuation: valuation,\n            lockedValuation: lockedValuation,\n            prepaidTaxBalance: prepaidTaxBalance,\n            taxPaidUntil: taxPaidUntil,\n            timeRemainingInSeconds: block.timestamp >= taxPaidUntil\n                ? 0\n                : taxPaidUntil - block.timestamp,\n            contentUpdateCount: contentUpdateCount,\n            contentUpdateLimit: contentUpdateLimit,\n            taxPeriodInSeconds: taxPeriodInSeconds,\n            annualTaxRate: annualTaxRate,\n            minBidIncrementRate: minBidIncrementRate,\n            bondRate: bondRate,\n            minValuation: minValuation,\n            baseValuation: baseValuation,\n            dustRate: dustRate,\n            currentAdURI: currentAdURI,\n            treasury: treasury,\n            governance: governance,\n            isOccupied: currentOwner != address(0)\n        });\n    }\n\n    function _calculateTax(uint256 valuation_, uint256 periods) internal view returns (uint256) {\n        uint256 numerator = valuation_ * annualTaxRate * taxPeriodInSeconds * periods;\n        return numerator / TAX_BASE;\n    }\n\n    function _calculateLockedAmount(uint256 valuation_) internal view returns (uint256) {\n        return (valuation_ * bondRate) / RATE_DENOMINATOR;\n    }\n\n    // TODO: Evaluate introducing an idempotent closed-form settlement formula.\n    function _settleOverdueTax() private {\n        if (currentOwner == address(0)) return;\n        if (block.timestamp < taxPaidUntil) return;\n\n        uint256 taxFactor = annualTaxRate * taxPeriodInSeconds;\n        if (taxFactor == 0) return;\n\n        uint256 taxDenominator = TAX_BASE + taxFactor;\n        uint256 dustThresholdValuation;\n        if (dustRate != 0 && baseValuation != 0) {\n            dustThresholdValuation = (baseValuation * dustRate) / RATE_DENOMINATOR;\n        }\n\n        uint256 overdueSeconds = block.timestamp - taxPaidUntil;\n        uint256 periodsDue = (overdueSeconds / taxPeriodInSeconds) + 1;\n        uint256 taxAccrued;\n        uint256 ownerRefund;\n\n        for (uint256 i = 0; i < periodsDue; ++i) {\n            uint256 previousValuation = valuation;\n            uint256 previousLocked = lockedValuation;\n\n            if (previousValuation == 0 || previousLocked == 0) {\n                if (prepaidTaxBalance > 0) {\n                    ownerRefund += prepaidTaxBalance;\n                    prepaidTaxBalance = 0;\n                }\n                valuation = 0;\n                lockedValuation = 0;\n                baseValuation = 0;\n                taxPaidUntil = block.timestamp;\n                break;\n            }\n\n            uint256 theoreticalValuation = (previousValuation * TAX_BASE) / taxDenominator;\n            uint256 theoreticalTax = previousValuation - theoreticalValuation;\n            uint256 taxRemaining = theoreticalTax;\n\n            if (prepaidTaxBalance > 0) {\n                uint256 taxFromPrepaid = prepaidTaxBalance >= taxRemaining ? taxRemaining : prepaidTaxBalance;\n                prepaidTaxBalance -= taxFromPrepaid;\n                taxRemaining -= taxFromPrepaid;\n                taxAccrued += taxFromPrepaid;\n            }\n\n            uint256 taxFromLocked;\n            if (taxRemaining > 0) {\n                if (taxRemaining >= previousLocked) {\n                    taxFromLocked = previousLocked;\n                    taxRemaining -= previousLocked;\n                } else {\n                    taxFromLocked = taxRemaining;\n                    taxRemaining = 0;\n                }\n                taxAccrued += taxFromLocked;\n            } else {\n                taxFromLocked = 0;\n            }\n\n            if (taxFromLocked >= previousLocked) {\n                valuation = 0;\n                lockedValuation = 0;\n                baseValuation = 0;\n                taxPaidUntil = block.timestamp;\n                if (prepaidTaxBalance > 0) {\n                    ownerRefund += prepaidTaxBalance;\n                    prepaidTaxBalance = 0;\n                }\n                break;\n            }\n\n            uint256 newValuation = taxRemaining == 0\n                ? theoreticalValuation\n                : previousValuation > taxFromLocked ? previousValuation - taxFromLocked : 0;\n            uint256 remainingLocked = previousLocked - taxFromLocked;\n\n            valuation = newValuation;\n            lockedValuation = remainingLocked;\n            taxPaidUntil += taxPeriodInSeconds;\n\n            if (dustThresholdValuation != 0 && valuation <= dustThresholdValuation) {\n                ownerRefund += remainingLocked;\n                valuation = 0;\n                lockedValuation = 0;\n                baseValuation = 0;\n                taxPaidUntil = block.timestamp;\n                if (prepaidTaxBalance > 0) {\n                    ownerRefund += prepaidTaxBalance;\n                    prepaidTaxBalance = 0;\n                }\n                break;\n            }\n\n            if (taxPaidUntil > block.timestamp) {\n                break;\n            }\n\n            if (valuation == 0 || lockedValuation == 0) {\n                ownerRefund += lockedValuation;\n                valuation = 0;\n                lockedValuation = 0;\n                baseValuation = 0;\n                taxPaidUntil = block.timestamp;\n                if (prepaidTaxBalance > 0) {\n                    ownerRefund += prepaidTaxBalance;\n                    prepaidTaxBalance = 0;\n                }\n                break;\n            }\n        }\n\n        if (taxAccrued > 0) {\n            _forwardToTreasury(taxAccrued);\n        }\n\n        if (ownerRefund > 0 && currentOwner != address(0)) {\n            _sendValue(payable(currentOwner), ownerRefund);\n        }\n    }\n\n    function _forwardToTreasury(uint256 amount) private {\n        emit TreasuryPayment(amount);\n        _sendValue(payable(treasury), amount);\n    }\n\n    function _sendValue(address payable to, uint256 amount) private {\n        emit FundsSent(to, amount);\n        (bool success, ) = to.call{value: amount}(\"\");\n        if (!success) revert TransferFailed();\n    }\n\n    receive() external payable {\n        revert InvalidAmount();\n    }\n\n    fallback() external payable {\n        revert InvalidAmount();\n    }\n}\n"
      },
      "project/contracts/ValuationTaxShieldedSlot.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.28;\n\n/**\n * @title ValuationTaxShieldedSlot\n * @notice Harberger-style slot where only a bonded fraction of the valuation is escrowed and refunded when coverage lapses.\n */\ncontract ValuationTaxShieldedSlot {\n    uint256 private constant RATE_DENOMINATOR = 1e4; // basis points (10000 = 100%)\n    uint256 private constant SECONDS_PER_YEAR = 365 days;\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    error Unauthorized();\n    error SlotOccupied();\n    error SlotVacant();\n    error InvalidAmount();\n    error InvalidParameter();\n    error ContentUpdateLimitReached();\n    error TaxStillActive();\n    error MinIncrementNotMet();\n    error TransferFailed();\n    error Reentrancy();\n\n    event SlotClaimed(address indexed newOwner, uint256 valuation, uint256 bondedAmount, uint256 paidThrough);\n    event SlotTakenOver(\n        address indexed previousOwner,\n        address indexed newOwner,\n        uint256 newValuation,\n        uint256 bondedAmount,\n        uint256 paidThrough\n    );\n    event SlotRenewed(address indexed owner, uint256 paidThrough);\n    event SlotForfeited(address indexed previousOwner);\n    event SlotReset(address indexed previousOwner);\n    event SlotExpired(address indexed previousOwner);\n    event SlotPoked(address indexed operator);\n    event AdCreativeUpdated(address indexed owner, string uri);\n    event TreasuryPayment(uint256 amount);\n    event FundsSent(address indexed to, uint256 amount);\n\n    address public immutable treasury;\n    address public immutable governance;\n    address public immutable factory;\n\n    uint256 public immutable bondRate;\n    uint256 public immutable contentUpdateLimit;\n    uint256 public immutable taxPeriodInSeconds;\n    uint256 public immutable annualTaxRate;\n    uint256 public immutable minBidIncrementRate;\n    uint256 public immutable minValuation;\n\n    address public currentOwner;\n    uint256 public valuation;\n    uint256 public bondedAmount;\n    uint256 public taxPaidUntil;\n    uint256 public prepaidTaxBalance;\n    uint256 public lastTaxSettlement;\n    uint256 public contentUpdateCount;\n    string public currentAdURI;\n\n    uint256 private _status;\n\n    struct SlotDetails {\n        address currentOwner;\n        uint256 valuation;\n        uint256 bondedAmount;\n        uint256 prepaidTaxBalance;\n        uint256 taxPaidUntil;\n        uint256 timeRemainingInSeconds;\n        bool isExpired;\n        uint256 contentUpdateCount;\n        uint256 contentUpdateLimit;\n        uint256 taxPeriodInSeconds;\n        uint256 annualTaxRate;\n        uint256 minBidIncrementRate;\n        uint256 bondRate;\n        uint256 minValuation;\n        string currentAdURI;\n        address treasury;\n        address governance;\n        bool isOccupied;\n    }\n\n    constructor(\n        address treasury_,\n        address governance_,\n        uint256 bondRate_,\n        uint256 contentUpdateLimit_,\n        uint256 taxPeriodInSeconds_,\n        uint256 annualTaxRate_,\n        uint256 minBidIncrementRate_,\n        uint256 minValuation_\n    ) {\n        if (treasury_ == address(0) || governance_ == address(0)) revert InvalidParameter();\n        if (taxPeriodInSeconds_ == 0 || annualTaxRate_ == 0) revert InvalidParameter();\n        if (bondRate_ == 0 || bondRate_ > RATE_DENOMINATOR) revert InvalidParameter();\n        if (minValuation_ == 0) revert InvalidParameter();\n\n        treasury = treasury_;\n        governance = governance_;\n        factory = msg.sender;\n        bondRate = bondRate_;\n        contentUpdateLimit = contentUpdateLimit_;\n        taxPeriodInSeconds = taxPeriodInSeconds_;\n        annualTaxRate = annualTaxRate_;\n        minBidIncrementRate = minBidIncrementRate_;\n        minValuation = minValuation_;\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        if (_status == _ENTERED) revert Reentrancy();\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != currentOwner) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyGovernance() {\n        if (msg.sender != governance) revert Unauthorized();\n        _;\n    }\n\n    function claim(uint256 newValuation, uint256 taxPeriods, string calldata newUri)\n        external\n        payable\n        nonReentrant\n    {\n        if (currentOwner != address(0)) revert SlotOccupied();\n        if (newValuation == 0 || taxPeriods == 0) revert InvalidParameter();\n        if (newValuation < minValuation) revert InvalidParameter();\n\n        uint256 bondRequired = _calculateBond(newValuation);\n        uint256 taxDue = _calculateTax(newValuation, taxPeriods);\n        if (taxDue == 0) revert InvalidParameter();\n\n        uint256 requiredValue = bondRequired + taxDue;\n        if (msg.value != requiredValue) revert InvalidAmount();\n\n        uint256 coverage = taxPeriodInSeconds * taxPeriods;\n\n        currentOwner = msg.sender;\n        valuation = newValuation;\n        bondedAmount = bondRequired;\n        taxPaidUntil = block.timestamp + coverage;\n        prepaidTaxBalance = taxDue;\n        lastTaxSettlement = block.timestamp;\n        contentUpdateCount = 0;\n        currentAdURI = newUri;\n\n        emit SlotClaimed(msg.sender, newValuation, bondRequired, taxPaidUntil);\n    }\n\n    function takeOver(uint256 newValuation, uint256 taxPeriods, string calldata newUri)\n        external\n        payable\n        nonReentrant\n    {\n        _expireIfNeeded();\n\n        address previousOwner = currentOwner;\n        if (previousOwner == address(0)) revert SlotVacant();\n        _settleAccruedTax();\n        uint256 refundableTax = prepaidTaxBalance;\n        prepaidTaxBalance = 0;\n        if (taxPeriods == 0 || newValuation == 0) revert InvalidParameter();\n        if (newValuation < minValuation) revert InvalidParameter();\n\n        uint256 minValuationRequired = valuation + ((valuation * minBidIncrementRate) / RATE_DENOMINATOR);\n        if (newValuation < minValuationRequired) revert MinIncrementNotMet();\n\n        uint256 bondRequired = _calculateBond(newValuation);\n        uint256 taxDue = _calculateTax(newValuation, taxPeriods);\n        if (taxDue == 0) revert InvalidParameter();\n\n        uint256 requiredValue = bondRequired + taxDue;\n        if (msg.value != requiredValue) revert InvalidAmount();\n\n        uint256 payout = bondedAmount;\n        uint256 coverage = taxPeriodInSeconds * taxPeriods;\n        uint256 paidThrough = block.timestamp + coverage;\n\n        currentOwner = msg.sender;\n        valuation = newValuation;\n        bondedAmount = bondRequired;\n        taxPaidUntil = paidThrough;\n        prepaidTaxBalance = taxDue;\n        lastTaxSettlement = block.timestamp;\n        contentUpdateCount = 0;\n        currentAdURI = newUri;\n\n        uint256 totalRefund = payout + refundableTax;\n        if (totalRefund > 0) {\n            _sendValue(payable(previousOwner), totalRefund);\n        }\n\n        emit SlotTakenOver(previousOwner, msg.sender, newValuation, bondRequired, paidThrough);\n    }\n\n    function renew(uint256 taxPeriods) external payable nonReentrant onlyOwner {\n        _expireIfNeeded();\n\n        if (currentOwner == address(0)) revert SlotVacant();\n        if (taxPeriods == 0) revert InvalidParameter();\n\n        _settleAccruedTax();\n\n        uint256 taxDue = _calculateTax(valuation, taxPeriods);\n        if (taxDue == 0) revert InvalidParameter();\n        if (msg.value != taxDue) revert InvalidAmount();\n\n        uint256 coverage = taxPeriodInSeconds * taxPeriods;\n        taxPaidUntil = taxPaidUntil + coverage;\n        prepaidTaxBalance += taxDue;\n        lastTaxSettlement = block.timestamp;\n\n        emit SlotRenewed(msg.sender, taxPaidUntil);\n    }\n\n    function forfeit() external nonReentrant onlyOwner {\n        _expireIfNeeded();\n\n        address previousOwner = currentOwner;\n        if (previousOwner == address(0)) revert SlotVacant();\n        if (block.timestamp >= taxPaidUntil) revert TaxStillActive();\n\n        _settleAccruedTax();\n\n        uint256 payout = bondedAmount;\n        uint256 refundableTax = prepaidTaxBalance;\n        prepaidTaxBalance = 0;\n\n        currentOwner = address(0);\n        valuation = 0;\n        bondedAmount = 0;\n        taxPaidUntil = 0;\n        lastTaxSettlement = 0;\n        contentUpdateCount = 0;\n        currentAdURI = \"\";\n\n        uint256 totalRefund = payout + refundableTax;\n        if (totalRefund > 0) {\n            _sendValue(payable(previousOwner), totalRefund);\n        }\n\n        emit SlotForfeited(previousOwner);\n    }\n\n    function governanceReset() external nonReentrant onlyGovernance {\n        _expireIfNeeded();\n\n        address previousOwner = currentOwner;\n        if (previousOwner == address(0)) revert SlotVacant();\n\n        _settleAccruedTax();\n\n        uint256 payout = bondedAmount;\n        uint256 refundableTax = prepaidTaxBalance;\n        prepaidTaxBalance = 0;\n\n        currentOwner = address(0);\n        valuation = 0;\n        bondedAmount = 0;\n        taxPaidUntil = 0;\n        lastTaxSettlement = 0;\n        contentUpdateCount = 0;\n        currentAdURI = \"\";\n\n        uint256 totalRefund = payout + refundableTax;\n        if (totalRefund > 0) {\n            _sendValue(payable(previousOwner), totalRefund);\n        }\n\n        emit SlotReset(previousOwner);\n    }\n\n    function poke() external nonReentrant {\n        if (currentOwner == address(0)) revert SlotVacant();\n        if (block.timestamp < taxPaidUntil) revert TaxStillActive();\n\n        _expireIfNeeded();\n\n        emit SlotPoked(msg.sender);\n    }\n\n    function updateAdCreative(string calldata newUri) external onlyOwner {\n        if (contentUpdateCount >= contentUpdateLimit) revert ContentUpdateLimitReached();\n\n        contentUpdateCount += 1;\n        currentAdURI = newUri;\n\n        emit AdCreativeUpdated(msg.sender, newUri);\n    }\n\n    function getSlotDetails() external view returns (SlotDetails memory details) {\n        bool expired = currentOwner != address(0) && block.timestamp >= taxPaidUntil;\n        uint256 timeRemaining = expired\n            ? 0\n            : (taxPaidUntil > block.timestamp ? taxPaidUntil - block.timestamp : 0);\n\n        details = SlotDetails({\n            currentOwner: currentOwner,\n            valuation: valuation,\n            bondedAmount: bondedAmount,\n            prepaidTaxBalance: prepaidTaxBalance,\n            taxPaidUntil: taxPaidUntil,\n            timeRemainingInSeconds: timeRemaining,\n            isExpired: expired,\n            contentUpdateCount: contentUpdateCount,\n            contentUpdateLimit: contentUpdateLimit,\n            taxPeriodInSeconds: taxPeriodInSeconds,\n            annualTaxRate: annualTaxRate,\n            minBidIncrementRate: minBidIncrementRate,\n            bondRate: bondRate,\n            minValuation: minValuation,\n            currentAdURI: currentAdURI,\n            treasury: treasury,\n            governance: governance,\n            isOccupied: currentOwner != address(0)\n        });\n    }\n\n    function _expireIfNeeded() private {\n        if (currentOwner == address(0)) return;\n        if (block.timestamp < taxPaidUntil) return;\n\n        _settleAccruedTax();\n        if (prepaidTaxBalance > 0) {\n            uint256 remainingTax = prepaidTaxBalance;\n            prepaidTaxBalance = 0;\n            _forwardToTreasury(remainingTax);\n        }\n\n        address previousOwner = currentOwner;\n        uint256 payout = bondedAmount;\n\n        currentOwner = address(0);\n        valuation = 0;\n        bondedAmount = 0;\n        taxPaidUntil = 0;\n        lastTaxSettlement = 0;\n        contentUpdateCount = 0;\n        currentAdURI = \"\";\n\n        if (payout > 0) {\n            _sendValue(payable(previousOwner), payout);\n        }\n\n        emit SlotExpired(previousOwner);\n    }\n\n    function _settleAccruedTax() private {\n        if (currentOwner == address(0)) return;\n\n        uint256 settlementEnd = taxPaidUntil;\n        if (settlementEnd == 0) return;\n\n        uint256 effectiveTime = block.timestamp < settlementEnd ? block.timestamp : settlementEnd;\n        if (effectiveTime <= lastTaxSettlement) return;\n\n        uint256 totalRemaining = settlementEnd - lastTaxSettlement;\n        if (totalRemaining == 0) {\n            lastTaxSettlement = settlementEnd;\n            return;\n        }\n\n        uint256 elapsed = effectiveTime - lastTaxSettlement;\n        uint256 prepaid = prepaidTaxBalance;\n        if (prepaid == 0) {\n            lastTaxSettlement = effectiveTime;\n            return;\n        }\n\n        uint256 taxToForward = (prepaid * elapsed) / totalRemaining;\n        if (elapsed == totalRemaining || taxToForward > prepaid) {\n            taxToForward = prepaid;\n        }\n\n        prepaidTaxBalance = prepaid - taxToForward;\n        lastTaxSettlement = effectiveTime;\n\n        if (taxToForward > 0) {\n            _forwardToTreasury(taxToForward);\n        }\n    }\n\n    function _calculateTax(uint256 valuation_, uint256 periods) internal view returns (uint256) {\n        uint256 numerator = valuation_ * annualTaxRate * taxPeriodInSeconds * periods;\n        return numerator / (RATE_DENOMINATOR * SECONDS_PER_YEAR);\n    }\n\n    function _calculateBond(uint256 valuation_) internal view returns (uint256) {\n        return (valuation_ * bondRate) / RATE_DENOMINATOR;\n    }\n\n    function _forwardToTreasury(uint256 amount) private {\n        emit TreasuryPayment(amount);\n        _sendValue(payable(treasury), amount);\n    }\n\n    function _sendValue(address payable to, uint256 amount) private {\n        emit FundsSent(to, amount);\n        (bool success, ) = to.call{value: amount}(\"\");\n        if (!success) revert TransferFailed();\n    }\n\n    receive() external payable {\n        revert InvalidAmount();\n    }\n\n    fallback() external payable {\n        revert InvalidAmount();\n    }\n}\n"
      }
    }
  }
}